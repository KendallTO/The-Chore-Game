<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Chore Game - Home</title>
    <link rel="stylesheet" href="styles.css">
</head>
<header class="site-header">
  
    <div class="container">
        <a href="index.html">
          <img class="logo" src="images/Logo_THE_GREAT_CHORE_OFF_Icon.png" alt="Logo">
        </a>
        <div class="container-logo">
          <a href="index.html">
            <img class src="images/Logo_THE_GREAT_CHORE_OFF_Text.png" href = "index.html" alt="The Chore Game">
          </a>
        </div>
          <nav class="main-nav">
              <a class="header-btn" href="index.html">Home</a>
              <a class ="header-btn" href="shop.html">Shop</a>
          </nav>
      </div>
</header>
<body>
    
<!-- ...existing code... -->
    <main class="site-main container">
        <section class="grid-3">
            <div class="column" id="column-left">
                <h3 class="column-header" contenteditable="true" spellcheck="false" style="text-transform: uppercase;" aria-label="Column 1 header">Enter Name Here</h3>

                <!-- left points bank (display only) -->
                <div class="points-bank">
                  <div>Points: <strong id="left-points">0</strong></div>
                </div>
 
                 <!-- left column chores -->
                 <div id="left-list">
                     <article class="card chore-placeholder">No chores assigned.</article>
                 </div>
             </div>

            <div class="column" id="chores-column">
                <h3 class="column-header" aria-label="Unchoosen Chores">Unassigned Chores</h3>

                <!-- random assign button -->
                <div class="button-container">
                    <button id="random-assign-btn" type="button" class="btn">Random</button>
                    <button id="auction-btn" type="button" class="btn">Auction</button>
                    <button id="draft-btn" type="button" class="btn">Draft</button>
                </div>

                <!-- unchosen chores list (rendered by JS) -->
                <div id="chores-list">
                    <article class="card chore-placeholder">No chores yet — add one below.</article>
                </div>

                <!-- add-chore form -->
                <form id="add-chore-form" class="chore-form" aria-label="Add chore" novalidate style="max-width: 400px; margin: 0 auto;">
                    <div class="form-row" style="display: flex; gap: 8px; align-items: center;">
                        <input id="chore-name" name="name" type="text" required aria-required="true" placeholder="Chore Name" style="margin-top: 0; width: 200px;" />
                        <button type="submit" id = "unchosen-button-add" class="btn">Add</button>
                    </div>
                </form>
            </div>

            <div class="column" id="column-right">
                 <h3 class="column-header" contenteditable="true" spellcheck="false" style="text-transform: uppercase;" aria-label="Column 3 header">Enter Name Here</h3>
 
                <!-- right points bank (display only) -->
                <div class="points-bank" id="right-points-bank" style="text-align: right;">
                  <div>Points: <strong id="right-points">0</strong></div>
                </div>

                <!-- right column chores -->
                <div id="right-list">
                    <article class="card chore-placeholder">No chores assigned.</article>
                </div>
             </div>
         </section>
     </main>
<!-- ...existing code... -->

    <footer class="site-footer">
        <div class="container">
            <p>© <span id="year"></span> The Great Chore-Off: Made By: Sean Heiner, Spiter-Man, & Kendall Olson!</p>
            </p>
        </div>
    </footer>
    
<!-- vvvv Java Script vvvv -->

    <script>
        document.getElementById('year').textContent = new Date().getFullYear();
    </script>

    <script>
    // chores: add, render, persist (localStorage)
    (function(){
      const STORAGE_KEY = 'tcg_chores_v1';
      const HEADERS_KEY = 'tcg_column_headers_v1';
      const POINTS_KEY = 'tcg_points_v1';
  const HEADER_MAX = 8; // Max characters allowed for left/right headers

      // points helpers
      function loadPoints(){
        try{
          const raw = localStorage.getItem(POINTS_KEY);
          return raw ? JSON.parse(raw) : { left: 0, right: 0 };
        }catch(e){
          return { left: 0, right: 0 };
        }
      }
      function savePoints(p){ localStorage.setItem(POINTS_KEY, JSON.stringify(p)); }
      function renderPoints(){
        const p = loadPoints();
        const leftEl = document.getElementById('left-points');
        const rightEl = document.getElementById('right-points');
        if(leftEl) leftEl.textContent = String(p.left || 0);
        if(rightEl) rightEl.textContent = String(p.right || 0);
      }

      // wire up quick controls (left/right buttons exist for left/right columns)
      document.addEventListener('DOMContentLoaded', () => {
        const leftAdd = document.getElementById('left-add-10');
        const leftReset = document.getElementById('left-reset');
        const rightAdd = document.getElementById('right-add-10');
        const rightReset = document.getElementById('right-reset');

        if(leftAdd){
          leftAdd.addEventListener('click', () => {
            const p = loadPoints(); p.left = (p.left||0) + 10; savePoints(p); renderPoints();
          });
        }
        if(leftReset){
          leftReset.addEventListener('click', () => {
            if(!confirm('Reset left points to 0?')) return;
            const p = loadPoints(); p.left = 0; savePoints(p); renderPoints();
          });
        }
        if(rightAdd){
          rightAdd.addEventListener('click', () => {
            const p = loadPoints(); p.right = (p.right||0) + 10; savePoints(p); renderPoints();
          });
        }
        if(rightReset){
          rightReset.addEventListener('click', () => {
            if(!confirm('Reset right points to 0?')) return;
            const p = loadPoints(); p.right = 0; savePoints(p); renderPoints();
          });
        }

        renderPoints();
      });


      // header elements (editable)
      const leftHeaderEl = document.querySelector('.grid-3 .column:nth-child(1) .column-header');
      const rightHeaderEl = document.querySelector('.grid-3 .column:nth-child(3) .column-header');

      function loadHeaders(){
        try{
          const raw = localStorage.getItem(HEADERS_KEY);
          const parsed = raw ? JSON.parse(raw) : {};
          return {
            left: parsed.left ?? (leftHeaderEl ? leftHeaderEl.textContent.trim() : 'Enter Name Here'),
            right: parsed.right ?? (rightHeaderEl ? rightHeaderEl.textContent.trim() : 'Enter Name Here')
          };
        }catch(e){
          return {
            left: leftHeaderEl ? leftHeaderEl.textContent.trim() : 'Enter Name Here',
            right: rightHeaderEl ? rightHeaderEl.textContent.trim() : 'Enter Name Here'
          };
        }
      }

      function saveHeaders(){
        if(!leftHeaderEl || !rightHeaderEl) return;
        const leftText = (leftHeaderEl.textContent || '').replace(/[\r\n]+/g, '').trim().slice(0, HEADER_MAX);
        const rightText = (rightHeaderEl.textContent || '').replace(/[\r\n]+/g, '').trim().slice(0, HEADER_MAX);
        const payload = { left: leftText, right: rightText };
        localStorage.setItem(HEADERS_KEY, JSON.stringify(payload));
      }

      // apply saved headers immediately
      const savedHeaders = loadHeaders();
      if(leftHeaderEl) leftHeaderEl.textContent = savedHeaders.left;
      if(rightHeaderEl) rightHeaderEl.textContent = savedHeaders.right;
      // save any normalization (optional)
      saveHeaders();

      // DOM elements used by the chores logic (ensure these are wired up)
      const leftListEl = document.getElementById('left-list');
      const unchosenListEl = document.getElementById('chores-list');
      const rightListEl = document.getElementById('right-list');
      const form = document.getElementById('add-chore-form');
      const nameInput = document.getElementById('chore-name');
      const msgEl = document.getElementById('chore-msg');

      // Track whether we're in draft mode (show manual assign buttons)
      let draftMode = false;

      // helper to show a transient message if msgEl exists
      function notify(message, durationMs = 1800){
        if(!msgEl) return;
        msgEl.textContent = message || '';
        if(message){
          setTimeout(() => { if(msgEl) msgEl.textContent = ''; }, durationMs);
        }
      }

      // chores have shape: { id, name, points, loc } where loc is 'unchosen'|'left'|'right'
      function loadChores(){
        try{
          const raw = localStorage.getItem(STORAGE_KEY);
          return raw ? JSON.parse(raw) : [];
        }catch(e){
          return [];
        }
      }

      function saveChores(chores){
        localStorage.setItem(STORAGE_KEY, JSON.stringify(chores));
      }

      function makeChoreCard(chore){
        const art = document.createElement('article');
        art.className = 'card chore';
        art.dataset.id = String(chore.id);
        art.dataset.loc = chore.loc || 'unchosen';
 
        const wrap = document.createElement('div');
        wrap.style.width = '100%';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.alignItems = 'center';
 
        const title = document.createElement('h4');
        title.textContent = chore.name;
        title.style.margin = '0 0 6px 0';
        title.style.textAlign = 'center';
        wrap.appendChild(title);
 
        const pts = document.createElement('p');
        pts.textContent = String(chore.points) + ' pts';
        pts.style.margin = '0 0 8px 0';
        pts.style.fontWeight = '600';
        pts.style.textAlign = 'center';
        wrap.appendChild(pts);
 
        const actions = document.createElement('div');
        actions.style.marginTop = '8px';
        actions.style.display = 'flex';
        actions.style.gap = '8px';
        actions.style.flexWrap = 'wrap';
        actions.style.justifyContent = 'center';
        actions.style.width = '100%';
 
        // read current column header text so labels match whatever the headers show
        const leftHeaderText = document.querySelector('.grid-3 .column:nth-child(1) .column-header')?.textContent.trim() || 'Left';
        const rightHeaderText = document.querySelector('.grid-3 .column:nth-child(3) .column-header')?.textContent.trim() || 'Right';
 
        // action buttons depend on location
        if(!chore.loc || chore.loc === 'unchosen'){
          // Only show assign buttons if in draft mode
          if(draftMode){
            const assignLeft = document.createElement('button');
            assignLeft.type = 'button';
            assignLeft.className = 'btn';
            assignLeft.textContent = `Assign → ${leftHeaderText.toUpperCase()}`;
            assignLeft.dataset.action = 'assign-left';
            actions.appendChild(assignLeft);
   
            const assignRight = document.createElement('button');
            assignRight.type = 'button';
            assignRight.className = 'btn';
            assignRight.textContent = `Assign → ${rightHeaderText.toUpperCase()}`;
            assignRight.dataset.action = 'assign-right';
            actions.appendChild(assignRight);
            
            // In draft mode, show delete button separately at bottom center
            wrap.appendChild(actions);
            
            const delWrap = document.createElement('div');
            delWrap.style.marginTop = '12px';
            delWrap.style.display = 'flex';
            delWrap.style.justifyContent = 'center';
            delWrap.style.width = '100%';
            
            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'btn btn-delete';
            del.textContent = 'Delete';
            del.dataset.action = 'delete';
            delWrap.appendChild(del);
            wrap.appendChild(delWrap);
            
            art.appendChild(wrap);
            return art;
          }
        } else {
          // show complete button for assigned chores
          const completeBtn = document.createElement('button');
          completeBtn.type = 'button';
          completeBtn.className = 'btn btn-purchase';
          completeBtn.textContent = 'Complete';
          completeBtn.dataset.action = 'complete';
          actions.appendChild(completeBtn);
 
          const unassign = document.createElement('button');
          unassign.type = 'button';
          unassign.className = 'btn';
          unassign.textContent = 'Unassign';
          unassign.dataset.action = 'unassign';
          actions.appendChild(unassign);
        }
 
        const del = document.createElement('button');
        del.type = 'button';
        del.className = 'btn btn-delete';
        del.textContent = 'Delete';
        del.dataset.action = 'delete';
        actions.appendChild(del);
 
        wrap.appendChild(actions);
        art.appendChild(wrap);
        return art;
      }

      function render(){
        const chores = loadChores();

        leftListEl.innerHTML = '';
        unchosenListEl.innerHTML = '';
        rightListEl.innerHTML = '';

        const left = chores.filter(c => c.loc === 'left');
        const right = chores.filter(c => c.loc === 'right');
        const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');

        if(!left.length){
          const ph = document.createElement('article');
          ph.className = 'card chore-placeholder';
          ph.textContent = 'No chores assigned.';
          leftListEl.appendChild(ph);
        } else {
          left.forEach(c => leftListEl.appendChild(makeChoreCard(c)));
        }

        if(!unchosen.length){
          const ph = document.createElement('article');
          ph.className = 'card chore-placeholder';
          ph.textContent = 'No chores yet — add one below.';
          unchosenListEl.appendChild(ph);
        } else {
          unchosen.forEach(c => unchosenListEl.appendChild(makeChoreCard(c)));
        }

        if(!right.length){
          const ph = document.createElement('article');
          ph.className = 'card chore-placeholder';
          ph.textContent = 'No chores assigned.';
          rightListEl.appendChild(ph);
        } else {
          right.forEach(c => rightListEl.appendChild(makeChoreCard(c)));
        }
      }

      form.addEventListener('submit', function(e){
        e.preventDefault();
        
        const name = nameInput.value.trim();
        const points = 10; // fixed starting value

        if(!name){
          nameInput.focus();
          return;
        }

        const chores = loadChores();
        const newChore = { id: Date.now(), name, points: Math.floor(points), loc: 'unchosen' };
        chores.push(newChore);
        saveChores(chores);
        draftMode = false; // Disable manual assign buttons when adding new chore
        render();
        form.reset();
      });

      // delegated action handler for all three lists
      document.querySelector('.grid-3').addEventListener('click', function(e){
        const btn = e.target.closest('button[data-action]');
        if(!btn) return;
        const action = btn.dataset.action;
        const card = btn.closest('.chore');
        if(!card) return;
        const id = Number(card.dataset.id);
        let chores = loadChores();
        const idx = chores.findIndex(c => c.id === id);
        if(idx === -1) return;

        // complete action: add chore.points to correct bank (left/right)
        if(action === 'complete'){
          const chore = chores[idx];
          const loc = chore.loc;
          if(!loc || (loc !== 'left' && loc !== 'right')){
            notify('Chore must be assigned to a column to complete.', 1800);
            return;
          }
          const points = loadPoints();
          points[loc] = (points[loc] || 0) + Number(chore.points || 0);
          savePoints(points);
          renderPoints();

          // remove the chore after completion
          chores.splice(idx, 1);
          saveChores(chores);
          render();

          notify(`${chore.name} completed — added ${chore.points} pts to ${loc}.`, 1800);
          return;
        }

        if(action === 'assign-left'){
          chores[idx].loc = 'left';
          saveChores(chores);
          render();
          return;
        }
        if(action === 'assign-right'){
          chores[idx].loc = 'right';
          saveChores(chores);
          render();
          return;
        }
        if(action === 'unassign'){
          chores[idx].loc = 'unchosen';
          // After unassigning, enable draft mode so manual assign buttons appear in the unassigned list
          draftMode = true;
          saveChores(chores);
          render();
          return;
        }
        if(action === 'delete'){
          // delete immediately without confirmation
          chores.splice(idx, 1);
          saveChores(chores);
          render();
          notify('Chore deleted.', 1400);
          return;
        }
      });

      // random assign button: distribute unchosen chores randomly to left or right
      const randomAssignBtn = document.getElementById('random-assign-btn');
      if(randomAssignBtn){
        // balanced assignment: aim for equal counts (difference at most 1)
        randomAssignBtn.addEventListener('click', function(){
          const chores = loadChores();
          const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');
          if(!unchosen.length){
            notify('No unassigned chores to assign.', 1800);
            return;
          }

          // count current items
          let leftCount = chores.filter(c => c.loc === 'left').length;
          let rightCount = chores.filter(c => c.loc === 'right').length;

          // shuffle unchosen so distribution is not deterministic
          for(let i = unchosen.length - 1; i > 0; i--){
            const j = Math.floor(Math.random() * (i + 1));
            [unchosen[i], unchosen[j]] = [unchosen[j], unchosen[i]];
          }

          // assign each unchosen chore to the column with fewer chores,
          // if equal pick randomly — this ensures near-equal distribution
          const idsToAssign = new Set(unchosen.map(c => c.id));
          chores.forEach(c => {
            if(!idsToAssign.has(c.id)) return;
            if(leftCount < rightCount){
              c.loc = 'left';
              leftCount++;
            } else if(rightCount < leftCount){
              c.loc = 'right';
              rightCount++;
            } else {
              // counts equal — pick randomly
              if(Math.random() < 0.5){ c.loc = 'left'; leftCount++; }
              else { c.loc = 'right'; rightCount++; }
            }
          });

          // Calculate points based on assignment order
          // First assigned chores get lower points, last assigned gets 50 points
          const currentlyAssigning = Array.from(idsToAssign).length;

          // Sort the IDs to assign so we process them in a consistent order
          const sortedIdsToAssign = Array.from(idsToAssign).sort();

          // Calculate points for each chore being assigned
          sortedIdsToAssign.forEach((id, index) => {
            const chore = chores.find(c => c.id === id);
            if (!chore) return;

            // For the very last chore being assigned
            if (index === currentlyAssigning - 1) {
              chore.points = 50;
            } else {
              // Scale points from 10 to 40 based on position
              const progress = index / (currentlyAssigning - 1);  // 0 to 1
              const basePoints = 10 + (progress * 30);  // 10 to 40
              // Round up to nearest 5
              chore.points = Math.ceil(basePoints / 5) * 5;
            }
          });

          draftMode = false; // Disable manual assignment buttons
          saveChores(chores);
          render();
          notify(`Assigned ${unchosen.length} chore(s) (balanced).`, 1800);
        });
      }

      // Auction flow helpers
      function askYesNo(message, yesLabel = 'Yes', noLabel = 'No'){
        return new Promise(resolve => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const p = document.createElement('p');
          p.textContent = message;
          const actions = document.createElement('div');
          actions.className = 'tcg-modal-actions';

          const yesBtn = document.createElement('button');
          yesBtn.textContent = yesLabel;
          const noBtn = document.createElement('button');
          noBtn.textContent = noLabel;

          function cleanup(result){
            document.removeEventListener('keydown', onKey);
            overlay.remove();
            resolve(result);
          }
          function onKey(e){
            if(e.key === 'Escape') cleanup(false);
            if(e.key === 'Enter') cleanup(true);
          }

          yesBtn.addEventListener('click', () => cleanup(true));
          noBtn.addEventListener('click', () => cleanup(false));
          document.addEventListener('keydown', onKey);

          actions.appendChild(noBtn);
          actions.appendChild(yesBtn);
          modal.appendChild(p);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
        });
      }

      // Helper for Draft: ask Easy or Hard
      function askHighOrLow(choreName){
        return new Promise(resolve => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const p = document.createElement('p');
          p.textContent = `How difficult is: ${choreName}`;
          const actions = document.createElement('div');
          actions.className = 'tcg-modal-actions';

          const highBtn = document.createElement('button');
          highBtn.textContent = 'Hard';
          const lowBtn = document.createElement('button');
          lowBtn.textContent = 'Easy';

          function cleanup(choice){
            overlay.remove();
            resolve(choice);
          }

          highBtn.addEventListener('click', () => cleanup('high'));
          lowBtn.addEventListener('click', () => cleanup('low'));

          actions.appendChild(lowBtn);
          actions.appendChild(highBtn);
          modal.appendChild(p);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
        });
      }

      async function auctionSingle(chore, leftName, rightName){
        let currentPrice = 45;
        let currentBidder = Math.random() < 0.5 ? 'left' : 'right';
        let lastAcceptedBid = null;
        let lastBidder = null;

        while(currentPrice >= 5){
          // Auto-assign at 5 points to the current bidder
          if(currentPrice === 5){
            chore.loc = currentBidder;
            chore.points = 5;
            return;
          }

          const bidderLabel = currentBidder === 'left' ? (leftName || 'Left') : (rightName || 'Right');
          const accepted = await askYesNo(`Will ${bidderLabel.toUpperCase()} take "${chore.name}" for ${currentPrice} points?`, 'Yes', 'No');
          if(accepted){
            lastAcceptedBid = currentPrice;
            lastBidder = currentBidder;
            currentPrice -= 5;
            currentBidder = currentBidder === 'left' ? 'right' : 'left';
            continue;
          } else {
            if(lastBidder){
              chore.loc = lastBidder;
              chore.points = lastAcceptedBid;
              return;
            } else {
              // nobody has accepted yet; lower price and offer to the other side
              currentPrice -= 5;
              currentBidder = currentBidder === 'left' ? 'right' : 'left';
              continue;
            }
          }
        }

        // Fallback: if loop exits, assign to last bidder or current at 5
        if(lastBidder){
          chore.loc = lastBidder;
          chore.points = lastAcceptedBid;
        } else {
          chore.loc = currentBidder;
          chore.points = 5;
        }
      }

      async function runAuction(){
        const chores = loadChores();
        const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');
        if(!unchosen.length){
          notify('No unassigned chores to auction.', 1800);
          return;
        }
        const headers = loadHeaders();
        for(const chore of unchosen){
          await auctionSingle(chore, headers.left, headers.right);
          saveChores(chores);
          render();
        }
        draftMode = false; // Disable manual assignment buttons
      }

      const auctionBtn = document.getElementById('auction-btn');
      if(auctionBtn){
        auctionBtn.addEventListener('click', () => { runAuction(); });
      }

      // Draft flow: ask High/Low for each chore and assign random points
      function randomInRange(min, max){
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function roundToNearest5(n){
        return Math.round(n / 5) * 5;
      }

      async function runDraft(){
        const chores = loadChores();
        const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');
        if(!unchosen.length){
          notify('No unassigned chores to draft.', 1800);
          return;
        }

        for(const chore of unchosen){
          const choice = await askHighOrLow(chore.name);
          let points;
          if(choice === 'high'){
            points = randomInRange(35, 50);
          } else {
            points = randomInRange(10, 30);
          }
          chore.points = roundToNearest5(points);
        }

        draftMode = true; // Enable manual assignment buttons
        saveChores(chores);
        render();
        notify(`Drafted ${unchosen.length} chore(s) with point values.`, 1800);
      }

      const draftBtn = document.getElementById('draft-btn');
      if(draftBtn){
        draftBtn.addEventListener('click', () => { runDraft(); });
      }

      // re-render when either column header text changes so button labels stay in sync
      [leftHeaderEl, rightHeaderEl].forEach(h => {
        if(!h) return;
        // save header text and re-render as the user types / on blur
        h.addEventListener('keydown', (e) => {
          // Block Enter/new line in contenteditable
          if(e.key === 'Enter'){
            e.preventDefault();
          }
        });
        h.addEventListener('input', () => {
          // Remove any newlines and enforce 8-char limit live while typing/pasting
          const raw = (h.textContent || '');
          const noNewlines = raw.replace(/[\r\n]+/g, '');
          const trimmed = noNewlines.trim();
          const limited = trimmed.length > HEADER_MAX ? trimmed.slice(0, HEADER_MAX) : trimmed;
          if(limited !== raw){
            h.textContent = limited;
          }
          saveHeaders();
          render();
        });
        h.addEventListener('blur', () => {
          // Ensure no newlines and limit also on blur
          const raw = (h.textContent || '');
          const noNewlines = raw.replace(/[\r\n]+/g, '');
          const trimmed = noNewlines.trim();
          const limited = trimmed.length > HEADER_MAX ? trimmed.slice(0, HEADER_MAX) : trimmed;
          if(limited !== raw){
            h.textContent = limited;
          }
          saveHeaders();
          render();
        });
      });

      // initial render
      render();
      // ensure point display is correct now (in case script ran before DOMContentLoaded)
      renderPoints();
    })();
    </script>
</body>
</html>
